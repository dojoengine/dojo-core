//! Manifests generated by the compiler.
//!
//! The manifests files contains metadata about
//! the contracts being compiled, since in Dojo
//! every resource is represented as a starknet contract.

use std::io::{Read, Write};

use anyhow::Result;
use dojo_types::naming;
use scarb::core::{Config, Workspace};
use serde::{Deserialize, Serialize};
use serde_with::serde_as;
use starknet::core::serde::unsigned_field_element::UfeHex;
use starknet::core::types::Felt;

use crate::aux_data::{AuxDataTrait, ContractAuxData, EventAuxData, ModelAuxData};
use crate::scarb_extensions::{FilesystemExt, WorkspaceExt};
use crate::{
    BASE_CONTRACT_TAG, CAIRO_PATH_SEPARATOR, CONTRACTS_DIR, EVENTS_DIR, MODELS_DIR,
    WORLD_CONTRACT_TAG,
};

const TOML_EXTENSION: &str = "toml";

/// Represents a member of a struct.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct Member {
    // Name of the member.
    pub name: String,
    // Type of the member.
    #[serde(rename = "type")]
    pub ty: String,
    // Whether the member is a key.
    pub key: bool,
}

pub trait ManifestMethods {
    fn type_name(&self) -> String;
    fn tag(&self) -> String;
    fn qualified_path(&self) -> String;
    fn to_toml_string(&self) -> Result<String, toml::ser::Error>;
}

pub trait FromAuxDataTrait<T> {
    fn from_aux_data(aux_data: &T, class_hash: Felt, qualified_path: &String) -> Self;
}

/// Represents the contract of a dojo contract.
#[serde_as]
#[derive(Clone, Default, Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(tag = "kind", rename = "DojoContract")]
pub struct ContractManifest {
    #[serde_as(as = "UfeHex")]
    pub class_hash: Felt,
    pub qualified_path: String,
    pub tag: String,
    pub systems: Vec<String>,
}

impl ManifestMethods for ContractManifest {
    fn type_name(&self) -> String {
        "contract".to_string()
    }

    fn tag(&self) -> String {
        self.tag.clone()
    }
    fn qualified_path(&self) -> String {
        self.qualified_path.clone()
    }
    fn to_toml_string(&self) -> Result<String, toml::ser::Error> {
        toml::to_string(self)
    }
}

impl FromAuxDataTrait<ContractAuxData> for ContractManifest {
    fn from_aux_data(
        aux_data: &ContractAuxData,
        class_hash: Felt,
        qualified_path: &String,
    ) -> Self {
        Self {
            class_hash,
            qualified_path: qualified_path.clone(),
            tag: aux_data.tag(),
            systems: aux_data.systems.clone(),
        }
    }
}

/// Represents the contract of a dojo model.
#[serde_as]
#[derive(Clone, Default, Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(tag = "kind", rename = "DojoModel")]
pub struct ModelManifest {
    #[serde_as(as = "UfeHex")]
    pub class_hash: Felt,
    pub qualified_path: String,
    pub tag: String,
    pub members: Vec<Member>,
}

impl ManifestMethods for ModelManifest {
    fn type_name(&self) -> String {
        "model".to_string()
    }

    fn tag(&self) -> String {
        self.tag.clone()
    }
    fn qualified_path(&self) -> String {
        self.qualified_path.clone()
    }
    fn to_toml_string(&self) -> Result<String, toml::ser::Error> {
        toml::to_string(self)
    }
}

impl FromAuxDataTrait<ModelAuxData> for ModelManifest {
    fn from_aux_data(aux_data: &ModelAuxData, class_hash: Felt, qualified_path: &String) -> Self {
        Self {
            class_hash,
            qualified_path: qualified_path.clone(),
            tag: aux_data.tag(),
            members: aux_data.members.clone(),
        }
    }
}

/// Represents the contract of a dojo event.
#[serde_as]
#[derive(Clone, Default, Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(tag = "kind", rename = "DojoEvent")]
pub struct EventManifest {
    #[serde_as(as = "UfeHex")]
    pub class_hash: Felt,
    pub qualified_path: String,
    pub tag: String,
    pub members: Vec<Member>,
}

impl ManifestMethods for EventManifest {
    fn type_name(&self) -> String {
        "event".to_string()
    }

    fn tag(&self) -> String {
        self.tag.clone()
    }
    fn qualified_path(&self) -> String {
        self.qualified_path.clone()
    }
    fn to_toml_string(&self) -> Result<String, toml::ser::Error> {
        toml::to_string(self)
    }
}

impl FromAuxDataTrait<EventAuxData> for EventManifest {
    fn from_aux_data(aux_data: &EventAuxData, class_hash: Felt, qualified_path: &String) -> Self {
        Self {
            class_hash,
            qualified_path: qualified_path.clone(),
            tag: aux_data.tag(),
            members: aux_data.members.clone(),
        }
    }
}

/// Represents a starknet contract.
#[serde_as]
#[derive(Clone, Default, Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(tag = "kind", rename = "StarknetContract")]
pub struct StarknetContractManifest {
    #[serde_as(as = "UfeHex")]
    pub class_hash: Felt,
    pub qualified_path: String,
    pub name: String,
}

/// An abstract representation of the manifest files combined.
///
/// An [`AbstractBaseManifest`] internalizes the workspace reference
/// to automatically provide the paths to the manifest files based on the
/// workspace configuration.
#[derive(Clone, Debug)]
pub struct AbstractBaseManifest<'w> {
    workspace: &'w Workspace<'w>,
    pub world: StarknetContractManifest,
    pub base: StarknetContractManifest,
    pub contracts: Vec<ContractManifest>,
    pub models: Vec<ModelManifest>,
    pub events: Vec<EventManifest>,
    pub sn_contracts: Vec<StarknetContractManifest>,
}

impl<'w> AbstractBaseManifest<'w> {
    /// Creates a new abstract base manifest.
    pub fn new(workspace: &'w Workspace) -> Self {
        Self {
            workspace,
            world: StarknetContractManifest::default(),
            base: StarknetContractManifest::default(),
            contracts: vec![],
            models: vec![],
            events: vec![],
            sn_contracts: vec![],
        }
    }

    pub fn read(&mut self) -> Result<()> {
        fn read_elements<T>(
            config: &Config,
            name: &str,
            dir: scarb::flock::Filesystem,
            vec: &mut Vec<T>,
        ) -> Result<()>
        where
            T: serde::de::DeserializeOwned,
        {
            for file_name in dir.list_files()? {
                let mut file = dir.open_ro(
                    &file_name,
                    &format!("{name} manifest for `{}`", &file_name),
                    config,
                )?;
                let mut s = String::new();
                file.read_to_string(&mut s)?;
                vec.push(toml::from_str(&s)?);
            }

            Ok(())
        }

        let base_dir = self.workspace.dojo_base_manfiests_dir_profile();

        read_elements(
            self.workspace.config(),
            "contract",
            base_dir.child(CONTRACTS_DIR),
            &mut self.contracts,
        )?;
        read_elements(
            self.workspace.config(),
            "model",
            base_dir.child(MODELS_DIR),
            &mut self.models,
        )?;
        read_elements(
            self.workspace.config(),
            "event",
            base_dir.child(EVENTS_DIR),
            &mut self.events,
        )?;

        for file_name in base_dir.list_files()? {
            let mut file = base_dir.open_ro(
                &file_name,
                &format!("starknet contract manifest for `{}`", &file_name),
                self.workspace.config(),
            )?;
            let mut sn_contract_str = String::new();
            file.read_to_string(&mut sn_contract_str)?;

            if file_name == format!("{}.toml", naming::get_filename_from_tag(WORLD_CONTRACT_TAG)) {
                self.world = toml::from_str(&sn_contract_str)?;
            } else if file_name
                == format!("{}.toml", naming::get_filename_from_tag(BASE_CONTRACT_TAG))
            {
                self.base = toml::from_str(&sn_contract_str)?;
            } else {
                self.sn_contracts.push(toml::from_str(&sn_contract_str)?);
            }
        }

        Ok(())
    }

    /// Writes the manifest to the given path.
    ///
    /// # Arguments
    ///
    /// * `path` - The path to write the manifest files to.
    pub fn write(&self) -> Result<()> {
        fn write_element<T>(
            config: &Config,
            dir: scarb::flock::Filesystem,
            elements: &Vec<T>,
        ) -> Result<()>
        where
            T: ManifestMethods,
        {
            for element in elements {
                let name = format!(
                    "{}.{}",
                    naming::get_filename_from_tag(&element.tag()),
                    TOML_EXTENSION
                );

                let mut file = dir.open_rw(
                    name,
                    &format!(
                        "{} manifest for `{}`",
                        element.type_name(),
                        element.qualified_path()
                    ),
                    config,
                )?;

                file.write(element.to_toml_string()?.as_bytes())?;
            }

            Ok(())
        }

        let base_dir = self.workspace.dojo_base_manfiests_dir_profile();

        let world = toml::to_string(&self.world)?;

        let mut file = base_dir.open_rw(
            format!("{}.toml", naming::get_filename_from_tag(WORLD_CONTRACT_TAG)),
            &format!("world manifest"),
            self.workspace.config(),
        )?;

        file.write(world.as_bytes())?;

        let base = toml::to_string(&self.base)?;

        let mut file = base_dir.open_rw(
            format!("{}.toml", naming::get_filename_from_tag(BASE_CONTRACT_TAG)),
            &format!("base manifest"),
            self.workspace.config(),
        )?;

        file.write(base.as_bytes())?;

        let config = self.workspace.config();
        write_element(config, base_dir.child(CONTRACTS_DIR), &self.contracts)?;
        write_element(config, base_dir.child(MODELS_DIR), &self.models)?;
        write_element(config, base_dir.child(EVENTS_DIR), &self.events)?;

        for sn_contract in &self.sn_contracts {
            let name = format!(
                "{}.{}",
                sn_contract
                    .qualified_path
                    .replace(CAIRO_PATH_SEPARATOR, "_"),
                TOML_EXTENSION
            );

            let mut file = base_dir.open_rw(
                name,
                &format!("starknet contract manifest for `{}`", sn_contract.name),
                self.workspace.config(),
            )?;

            file.write(toml::to_string(sn_contract)?.as_bytes())?;
        }

        Ok(())
    }
}
