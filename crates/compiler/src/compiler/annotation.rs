//! Dojo resource annotations.
//!
//! The dojo resource annotations are used to annotate the artifacts
//! generated by the compiler with information about the Dojo resources
//! found during the compilation process.

use std::io::{Read, Write};

use anyhow::Result;
use scarb::core::Workspace;
use serde::{Deserialize, Serialize};
use serde_with::serde_as;
use starknet::core::serde::unsigned_field_element::UfeHex;
use starknet::core::types::Felt;

use crate::scarb_extensions::WorkspaceExt;
use crate::{BASE_CONTRACT_TAG, BASE_QUALIFIED_PATH, WORLD_CONTRACT_TAG, WORLD_QUALIFIED_PATH};

const DOJO_ANNOTATION_FILE_NAME: &str = "annotations";

/// Represents a member of a struct.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct Member {
    // Name of the member.
    pub name: String,
    // Type of the member.
    #[serde(rename = "type")]
    pub ty: String,
    // Whether the member is a key.
    pub key: bool,
}

/// Represents the annotations of a dojo contract.
#[serde_as]
#[derive(Clone, Default, Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(tag = "kind", rename = "DojoContract")]
pub struct ContractAnnotation {
    #[serde_as(as = "UfeHex")]
    pub class_hash: Felt,
    pub qualified_path: String,
    pub tag: String,
    pub systems: Vec<String>,
}

/// Represents the annotations of a dojo model.
#[serde_as]
#[derive(Clone, Default, Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(tag = "kind", rename = "DojoModel")]
pub struct ModelAnnotation {
    #[serde_as(as = "UfeHex")]
    pub class_hash: Felt,
    pub qualified_path: String,
    pub tag: String,
    pub members: Vec<Member>,
}

/// Represents the annotations of a dojo event.
#[serde_as]
#[derive(Clone, Default, Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(tag = "kind", rename = "DojoEvent")]
pub struct EventAnnotation {
    #[serde_as(as = "UfeHex")]
    pub class_hash: Felt,
    pub qualified_path: String,
    pub tag: String,
    pub members: Vec<Member>,
}

/// Represents the world contract annotation.
#[serde_as]
#[derive(Clone, Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(tag = "kind", rename = "DojoWorld")]
pub struct WorldAnnotation {
    #[serde_as(as = "UfeHex")]
    pub class_hash: Felt,
    pub qualified_path: String,
    pub tag: String,
}

impl Default for WorldAnnotation {
    fn default() -> Self {
        Self {
            class_hash: Felt::ZERO,
            qualified_path: WORLD_QUALIFIED_PATH.to_string(),
            tag: WORLD_CONTRACT_TAG.to_string(),
        }
    }
}

/// Represents the base contract annotation.
#[serde_as]
#[derive(Clone, Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(tag = "kind", rename = "DojoBase")]
pub struct BaseAnnotation {
    #[serde_as(as = "UfeHex")]
    pub class_hash: Felt,
    pub qualified_path: String,
    pub tag: String,
}

impl Default for BaseAnnotation {
    fn default() -> Self {
        Self {
            class_hash: Felt::ZERO,
            qualified_path: BASE_QUALIFIED_PATH.to_string(),
            tag: BASE_CONTRACT_TAG.to_string(),
        }
    }
}

/// Represents the annotations of a starknet contract.
#[serde_as]
#[derive(Clone, Default, Debug, Serialize, Deserialize)]
#[cfg_attr(test, derive(PartialEq))]
#[serde(tag = "kind", rename = "StarknetContract")]
pub struct StarknetContractAnnotation {
    #[serde_as(as = "UfeHex")]
    pub class_hash: Felt,
    pub qualified_path: String,
    pub name: String,
}

/// An abstract representation of the annotations of dojo resources.
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct DojoAnnotation {
    pub world: WorldAnnotation,
    pub base: BaseAnnotation,
    pub contracts: Vec<ContractAnnotation>,
    pub models: Vec<ModelAnnotation>,
    pub events: Vec<EventAnnotation>,
    pub sn_contracts: Vec<StarknetContractAnnotation>,
}

impl DojoAnnotation {
    /// Creates a new abstract base manifest.
    pub fn new() -> Self {
        Self {
            world: WorldAnnotation::default(),
            base: BaseAnnotation::default(),
            contracts: vec![],
            models: vec![],
            events: vec![],
            sn_contracts: vec![],
        }
    }

    /// Checks if the provided qualified path is a dojo resource.
    pub fn is_dojo_resource(&self, qualified_path: &str) -> bool {
        self.contracts
            .iter()
            .any(|c| c.qualified_path == qualified_path)
            || self
                .models
                .iter()
                .any(|m| m.qualified_path == qualified_path)
            || self
                .events
                .iter()
                .any(|e| e.qualified_path == qualified_path)
            || self.world.qualified_path == qualified_path
            || self.base.qualified_path == qualified_path
    }

    /// Reads the annotations from the target directory of the provided workspace,
    /// for the current profile.
    ///
    /// # Arguments
    ///
    /// * `workspace` - The workspace to read the annotations from.
    pub fn read(workspace: &Workspace) -> Result<Self> {
        let target_dir = workspace.target_dir_profile();

        let mut file = target_dir.open_ro(
            format!("{}.toml", DOJO_ANNOTATION_FILE_NAME),
            &format!("Dojo annotations"),
            workspace.config(),
        )?;

        let mut content = String::new();
        file.read_to_string(&mut content)?;

        let annotations = toml::from_str(&content)?;

        Ok(annotations)
    }

    /// Writes the annotations to the target directory of the provided workspace,
    /// for the current profile.
    ///
    /// # Arguments
    ///
    /// * `workspace` - The workspace to write the annotations to.
    pub fn write(&self, workspace: &Workspace) -> Result<()> {
        let target_dir = workspace.target_dir_profile();
        let content = toml::to_string(&self)?;

        let mut file = target_dir.open_rw(
            format!("{}.toml", DOJO_ANNOTATION_FILE_NAME),
            &format!("Dojo annotations"),
            workspace.config(),
        )?;

        file.write(content.as_bytes())?;

        Ok(())
    }
}
